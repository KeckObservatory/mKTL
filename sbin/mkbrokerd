#! /usr/bin/env python3

description = """
The broker daemon acts as a clearing house for configuration requests;
when daemons first start running they will seek out any brokers on their
local network and announce configuration updates; any clients broadcasting
will discover a local broker, and ask for any available configuration
information.

Daemons and clients can both bypass broadcast discovery for a local broker
if they already know where to find a broker.
"""

import argparse
import logging
import sys
import threading
import time

import mktl

logging.basicConfig(format='%(created)f %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)


def main():

    # We don't use command line options here, but if we did, they would be
    # parsed out in the following call. At the very least, it handles the
    # case where the caller specifies -h on the command line.

    config = parse_command_line()

    main.req = RequestServer()
    main.beacon = mktl.protocol.discover.Server(main.req.port)

    delay = 30

    while True:
        not_seen = set(main.known)
        discovered = mktl.protocol.discover.search_direct()

        for seen in discovered:
            if seen in main.known:
                not_seen.remove(seen)
                continue

            # This is a new daemon to us. Request its known hashes, which
            # also tells us which store names it has access to; cache any/all
            # configuration blocks discovered in this fashion.

            address,port = seen
            request = mktl.protocol.message.Request('HASH')
            try:
                payload = mktl.protocol.request.send(address, port, request)
            except:
                logger.warning("HASH request from %s:%d failed" % (address, port))
                continue

            hashes = payload.value

            for store in hashes.keys():
                request = mktl.protocol.message.Request('CONFIG', store)
                payload = mktl.protocol.request.send(address, port, request)

                blocks = payload.value
                error = payload.error

                if error:
                    e_type = error['type']
                    e_text = error['text']
                    logger.warning("CONFIG request failed: %s: %s" % (e_type, e_text))

                if blocks:
                    for uuid,block in blocks.items():
                        block['override'] = True
                        main.req.process_block(block)

            main.known.add(seen)

        for missed in not_seen:
            main.known.remove(missed)

        try:
            main.shutdown.wait(delay)
        except (KeyboardInterrupt, SystemExit):
            break


main.known = set()
main.shutdown = threading.Event()
main.req = None



def parse_command_line():

    arguments = dict()
    arguments['formatter_class'] = argparse.RawDescriptionHelpFormatter
    arguments['description'] = description
    ##arguments['epilog'] = epilog

    parser = argparse.ArgumentParser(**arguments)

    parsed = parser.parse_args()
    return parsed



class RequestServer(mktl.protocol.request.Server):
    """ Subclass the generic :class:mktl.protocol.request.Server`, adding
        additional logic to locally handle requests.
    """

    def check_keys(self, new, override):
        """ Confirm that any keys unique to this new configuration block are
            not present in any other blocks.
        """

        store = new['store']
        config = mktl.config.get(store)

        if len(config) == 0:
            # No previously stored blocks to check against. That means all of
            # the keys are unique, and there are no conflicts.
            return

        items = new['items']
        uuid = new['uuid']
        to_remove = set()

        for old_uuid in config.uuids():

            if uuid == old_uuid:
                # Doesn't make sense to check a block for duplicates against
                # any version of itself. Skip this one.
                continue

            old = config[old_uuid]
            running = None

            old_items = old['items']
            for key in old_items:
                if key in items:
                    if override == True:
                        if running is None:
                            running = self.check_running(old)

                        if running == True:
                            alias = old['alias']
                            old_port = old['provenance'][0]['rep']
                            old_host = old['provenance'][0]['hostname']
                            raise RuntimeError("%s contains %s, and is running at %s:%s" % (alias, key, old_host, old_port))
                        else:
                            # Override requested, and the old daemon is not
                            # running. Can't remove the UUID right now because
                            # we're busy iterating on it.
                            to_remove.add(uuid)

                    else:
                        alias = new['alias']
                        port = new['provenance'][0]['rep']
                        host = new['provenance'][0]['hostname']
                        logger.error("reject: %s from %s:%s (%s)" % (alias, host, port, uuid))
                        raise KeyError('key in new configuration block conflicts with an existing key: ' + key)

        # This set will be empty unless overrides were requested.

        for uuid in to_remove:
            try:
                block = config[uuid]
            except KeyError:
                # Already gone. Not entirely sure how that might have happened,
                # but it does, and there's no sense trying to remove it twice.
                continue

            alias = block['alias']
            port = block['provenance'][0]['rep']
            host = block['provenance'][0]['hostname']

            logger.info("forget: %s from %s:%s (%s)" % (alias, host, port, uuid))
            config.remove(uuid)


    def check_provenance(self, block):
        """ Look for provenance loops, and potentially (in the future) other
            problems with the provenance.
        """

        local_provenance = dict()
        local_provenance['hostname'] = self.hostname
        local_provenance['rep'] = self.port

        if mktl.config.contains_provenance(block, local_provenance):
            raise ProvenanceLoopError('circular provenance detected')


    def check_running(self, block):
        """ Check to see whether the daemon associated with this
            configuration block is still running.
        """

        # Take advantage of a built-in keyword to probe whether the
        # remote daemon is online and answering questions.

        store = block['store']
        alias = block['alias']
        clock = '_' + alias + 'clk'
        key = store + '.' + clock

        payload = mktl.protocol.message.Payload(None, refresh=True)
        request = mktl.protocol.message.Request('GET', key, payload)

        # Traverse the provenance by highest stratum number first.

        provenance = block['provenance']
        provenance = list(provenance)
        provenance.reverse()

        for stratum in provenance:
            # Only an authoritative stratum will have a 'pub' entry.
            try:
                stratum['pub']
            except KeyError:
                continue

            hostname = stratum['hostname']
            port = stratum['rep']
            request.response = None

            try:
                payload = mktl.protocol.request.send(hostname, port, request)
            except TimeoutError:
                continue

            if payload.value is not None:
                return True

        return False


    def process_block(self, new):

        store = new['store']
        config = mktl.config.get(store)

        self.check_provenance(new)

        # If the only provenance entry is stratum zero this new block
        # is authoritative. If the daemon responsible for the block
        # is requesting an override we have to apply some additional
        # conditions to the checks embedded here.

        if len(new['provenance']) == 1:
            authoritative = True
        else:
            authoritative = False

        try:
            override = new['override']
        except KeyError:
            override = False
        else:
            # Won't be needing that going forward. The presence of an
            # override flag is only relevant right now, as part of these
            # checks being performed right here for an 'announce' operation.
            del new['override']

        uuid = new['uuid']
        alias = new['alias']

        try:
            old = config[uuid]
        except KeyError:
            old = None

        if old is None:
            # Maybe it's a different UUID, but the same alias.

            try:
                old = config[alias]
            except KeyError:
                pass

            if old and old['uuid'] != uuid and authoritative == True:
                if override == True:
                    running = self.check_running(old)
                    if running == True:
                        old_port = old['provenance'][0]['rep']
                        old_host = old['provenance'][0]['hostname']
                        new_port = new['provenance'][0]['rep']
                        new_host = new['provenance'][0]['hostname']
                        logger.error("reject: %s from %s:%s (%s)" % (alias, new_host, new_port, uuid))
                        raise RuntimeError("%s is running at %s:%s" % (alias, old_host, old_port))


        if old and authoritative == True:
            # Does the provenance match? If not, we need an override to
            # proceed, but even then we should only proceed if the previous
            # daemon is offline.

            match = mktl.config.match_provenance(old['provenance'], new['provenance'])
            if match == False and override == False:
                old_port = old['provenance'][0]['rep']
                old_host = old['provenance'][0]['hostname']
                new_port = new['provenance'][0]['rep']
                new_host = new['provenance'][0]['hostname']

                logger.error("reject: %s from %s:%s (%s)" % (alias, new_host, new_port, uuid))
                raise ValueError("%s expected to be running at %s:%s, you are %s:%s" % (alias, old_host, old_port, new_host, new_port))

            if match == False and override == True:
                running = self.check_running(old)

                if running == True:
                    port = old['provenance'][0]['rep']
                    host = old['provenance'][0]['hostname']
                    raise ValueError("%s daemon already running at %s:%s" % (alias, host, port))

                # Else the local configuration should be updated to reflect
                # this new configuration block. Remove the old one to streamline
                # further checks.

                port = old['provenance'][0]['rep']
                host = old['provenance'][0]['hostname']
                logger.info("forget: %s from %s:%s (%s)" % (alias, host, port, uuid))
                config.remove(uuid)

            # We've already seen a block for this UUID. Accept the new block
            # for processing if and only if it is different, or has a newer
            # timestamp than what we know.

            if old['hash'] == new['hash'] and old['time'] >= new['time']:
                # We already know this block.
                return

        # Reject a configuration block if it contains keys that collide
        # with another block in the cache. Not looking for a return
        # value from check_keys(), exceptions are raised when there are
        # problems.

        self.check_keys(new, override)

        # Now that all the checks have passed it's time to update the local
        # cache of configuration data.

        mktl.config.add_provenance(new, self.hostname, self.port)
        port = new['provenance'][0]['rep']
        host = new['provenance'][0]['hostname']

        logger.info("remember: %s from %s:%s (%s)" % (alias, host, port, uuid))
        config.update(new)


    def req_config(self, request):
        """ When a daemon announces a configuration block it will be the payload
            of the request, otherwise, for a query the payload is empty. The
            response for a payload is ignored, though the presence or absence of
            exceptions is significant. The response to a configuration request
            is a sequence of configuration blocks representing the full known
            configuration for the specified store, with a single block
            corresponding to a single daemon.
        """

        store = request.target
        payload = request.payload

        if payload is None or payload.value is None:
            try:
                config = mktl.config.get(store)
            except KeyError:
                response = tuple()
            else:
                response = config._by_uuid

            if len(response) == 0:
                raise KeyError('no configuration available for ' + repr(store))

        else:
            response = True
            block = payload.value

            try:
                self.process_block(block)
            except ProvenanceLoopError:
                # This configuration block came from us. Pay no mind.
                pass

            provenance = block['provenance'][0]
            seen = (provenance['hostname'], provenance['rep'])
            main.known.add(seen)


        payload = mktl.Payload(response)
        return payload


    def req_handler(self, request):
        """ Inspect the incoming request type and decide how a response
            will be generated.
        """

        self.req_ack(request)

        type = request.type
        target = request.target

        if type != 'HASH' and target == '':
            raise KeyError('invalid request, no store/name specified')

        if type == 'HASH':
            payload = self.req_hash(request)
        elif type == 'CONFIG':
            payload = self.req_config(request)
        else:
            raise ValueError('invalid request type: ' + type)

        return payload


    def req_hash(self, request):
        """ Return the hash of a configuration block for a requested store name,
            or all hashes for all locally known stores.
        """

        store = request.target
        if store == '':
            store = None

        try:
            hashes = mktl.config.get_hashes(store)
        except KeyError:
            raise KeyError('no local configuration for ' + repr(store))

        payload = mktl.Payload(hashes)
        return payload


# end of class RequestServer


class ProvenanceLoopError(RuntimeError):
    pass


if __name__ == '__main__':
    main()

# vim: set expandtab tabstop=8 softtabstop=4 shiftwidth=4 autoindent:
