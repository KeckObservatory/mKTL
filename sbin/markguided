#! /usr/bin/env python3

description = """
The guide daemon acts as a broker for configuration requests; when daemons
first start running they will seek out any guides on their local network
and provide configuration updates; any clients broadcasting will discover
a local guide, and ask for any available configuration information.

Daemons and clients can both bypass broadcast discovery for a local guide
if they already know where to find a guide.
"""

import argparse
import threading
import zmq

import mktl


def main():

    # We don't use command line options here, but if we did, they would be
    # parsed out in the following call. At the very least, it handles the
    # case where the caller specifies -h on the command line.

    config = parse_command_line()

    main.req = RequestServer()
    main.beacon = mktl.protocol.discover.Server(main.req.port)

    delay = 30
    ### It needs to be possible to manipulate this set from the
    ### RequestServer on a CONFIG 'push' request.
    known = set()

    while True:
        not_seen = set(known)
        discovered = mktl.protocol.discover.search_direct()

        for seen in discovered:
            if seen in known:
                not_seen.remove(seen)
                continue

            # This is a new daemon to us. Request its known hashes, which
            # also tells us which store names it has access to; cache any/all
            # configuration blocks discovered in this fashion.

            address,port = seen
            request = mktl.protocol.message.Request('HASH')
            try:
                payload = mktl.protocol.request.send(address, port, request)
            except:
                ## This should probably be logged instead of going to stdout.
                print("HASH request of %s:%d failed" % (address, port))
                continue

            hashes = payload.value

            for store in hashes.keys():
                request = mktl.protocol.message.Request('CONFIG', store)
                payload = mktl.protocol.request.send(address, port, request)

                blocks = payload.value
                if blocks is None:
                    ## No data; there's probably an error we could inspect
                    ## and log here.
                    pass
                else:
                    for uuid,block in blocks.items():
                        store = block['store']
                        config = mktl.config.get(store)
                        config.update(block)

            known.add(seen)

        for missed in not_seen:
            known.remove(missed)

        try:
            main.shutdown.wait(delay)
        except (KeyboardInterrupt, SystemExit):
            break


main.shutdown = threading.Event()
main.req = None



def parse_command_line():

    arguments = dict()
    arguments['formatter_class'] = argparse.RawDescriptionHelpFormatter
    arguments['description'] = description
    ##arguments['epilog'] = epilog

    parser = argparse.ArgumentParser(**arguments)

    parsed = parser.parse_args()
    return parsed



class RequestServer(mktl.protocol.request.Server):
    """ Subclass the generic :class:mktl.protocol.request.Server`, adding
        additional logic to locally handle requests.
    """

    def check_keys(self, new):
        """ Confirm that any keys unique to this new configuration block are
            not present in any other blocks.
        """

        store = new['store']
        config = mktl.config.get(store)

        if len(config) == 0:
            # No previously stored blocks to check against. That means all of
            # the keys are unique, and there are no conflicts.
            return

        items = new['items']
        uuid = new['uuid']

        for old_uuid in config.uuids():

            if uuid == old_uuid:
                # Doesn't make sense to check a block for duplicates against
                # any version of itself. Skip this one.
                continue

            old = config[old_uuid]

            old_items = old['items']
            for key in old_items:
                if key in items:
                    raise KeyError('key in new configuration block conflicts with an existing key: ' + key)


    def check_provenance(self, block):
        """ Look for provenance loops, and potentially (in the future) other
            problems with the provenance.
        """

        local_provenance = dict()
        local_provenance['hostname'] = self.hostname
        local_provenance['rep'] = self.port

        if mktl.config.contains_provenance(block, local_provenance):
            raise ProvenanceLoopError('circular provenance detected')


    def check_running(self, block):
        """ Check to see whether the daemon associated with this
            configuration block is still running.
        """

        # Take advantage of a built-in keyword to probe whether the
        # remote daemon is online and answering questions.

        store = block['store']
        alias = block['alias']
        clock = alias + 'clk'
        key = store + '.' + clock

        payload = mktl.protocol.message.Payload(None, refresh=True)
        request = mktl.protocol.message.Request('GET', key, payload)

        # Traverse the provenance by highest stratum number first.

        provenance = block['provenance']
        provenance = list(provenance)
        provenance.reverse()

        for stratum in provenance:
            # Only an authoritative stratum will have a 'pub' entry.
            try:
                stratum['pub']
            except KeyError:
                continue

            hostname = stratum['hostname']
            port = stratum['rep']
            request.response = None

            try:
                payload = mktl.protocol.request.send(hostname, port, request)
            except zmq.ZMQError:
                continue

            if payload.value is not None:
                return True

        return False


    def process_block(self, new):

        store = new['store']
        config = mktl.config.get(store)

        self.check_provenance(new)

        # If the only provenance entry is stratum zero this new block
        # is authoritative. If the daemon responsible for the block
        # is requesting an override we have to apply some additional
        # conditions to the checks embedded here.

        if len(new['provenance']) == 1:
            authoritative = True
        else:
            authoritative = False

        try:
            override = new['override']
        except KeyError:
            override = False
        else:
            # Won't be needing that going forward. The presence of an
            # override flag is only relevant right now, as part of these
            # checks being performed right here for an 'announce' operation.
            del new['override']

        uuid = new['uuid']
        alias = new['alias']

        try:
            old = config[uuid]
        except KeyError:
            old = None

        if old is None:
            # Maybe it's a different UUID, but the same alias.

            try:
                old = config[alias]
            except KeyError:
                pass

            if old and old['uuid'] != uuid and authoritative == True:
                if override == True:
                    print('check for running daemon (uuid mismatch)')
                    running = self.check_running(old)
                    if running == True:
                        old_port = old['provenance'][0]['rep']
                        old_host = old['provenance'][0]['hostname']
                        raise RuntimeError("%s is running at %s:%s" % (alias, old_host, old_port))


        if old and authoritative == True:
            # Does the provenance match? If not, we need an override to
            # proceed, but even then we should only proceed if the previous
            # daemon is offline.

            match = mktl.config.match_provenance(old['provenance'], new['provenance'])
            if match == False and override == False:
                old_port = old['provenance'][0]['rep']
                old_host = old['provenance'][0]['hostname']
                new_port = new['provenance'][0]['rep']
                new_host = new['provenance'][0]['hostname']

                raise ValueError("%s expected to be running at %s:%s, you are %s:%s" % (alias, old_host, old_port, new_host, new_port))

            if match == False and override == True:
                print('check for running daemon')
                running = self.check_running(old)

                if running == True:
                    raise ValueError("daemon already running at %s:%s" % (host, port))

                # Else the local configuration should be updated to reflect
                # this new configuration block. Remove the old one to streamline
                # further checks.

                config.remove(uuid)

            # We've already seen a block for this UUID. Accept the new block
            # for processing if and only if it is different, or has a newer
            # timestamp than what we know.

            if old['hash'] == new['hash'] and old['time'] >= new['time']:
                # We already know this block.
                return

        # Reject a configuration block if it contains keys that collide
        # with another block in the cache. Not looking for a return
        # value from check_keys(), exceptions are raised when there are
        # problems.

        self.check_keys(new)

        # Now that all the checks have passed it's time to update the local
        # cache of configuration data.

        mktl.config.add_provenance(new, self.hostname, self.port)
        config.update(new)


    def req_config(self, request):
        """ When a daemon announces a configuration block it will be the payload
            of the request, otherwise, for a query the payload is empty. The
            response for a payload is ignored, though the presence or absence of
            exceptions is significant. The response to a configuration request
            is a sequence of configuration blocks representing the full known
            configuration for the specified store, with a single block
            corresponding to a single daemon.
        """

        store = request.target
        payload = request.payload

        if payload is None or payload.value is None:
            try:
                config = mktl.config.get(store)
            except KeyError:
                response = tuple()
            else:
                response = config._by_uuid

            if len(response) == 0:
                raise KeyError('no configuration available for ' + repr(store))

        else:
            response = True

            try:
                self.process_block(payload.value)
            except ProvenanceLoopError:
                # This configuration block came from us. Pay no mind.
                pass


        payload = mktl.Payload(response)
        return payload


    def req_handler(self, socket, lock, ident, request):
        """ Inspect the incoming request type and decide how a response
            will be generated.
        """

        self.req_ack(socket, lock, ident, request)

        type = request.type
        target = request.target

        if type != 'HASH' and target == '':
            raise KeyError('invalid request, no store/name specified')

        if type == 'HASH':
            payload = self.req_hash(request)
        elif type == 'CONFIG':
            payload = self.req_config(request)
        else:
            raise ValueError('invalid request type: ' + type)

        return payload


    def req_hash(self, request):
        """ Return the hash of a configuration block for a requested store name,
            or all hashes for all locally known stores.
        """

        store = request.target
        if store == '':
            store = None

        try:
            hashes = mktl.config.get_hashes(store)
        except KeyError:
            raise KeyError('no local configuration for ' + repr(store))

        payload = mktl.Payload(hashes)
        return payload


# end of class RequestServer


class ProvenanceLoopError(RuntimeError):
    pass


if __name__ == '__main__':
    main()

# vim: set expandtab tabstop=8 softtabstop=4 shiftwidth=4 autoindent:
