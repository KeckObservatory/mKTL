#! /usr/bin/env python3

description = """
This is the mKTL command line interface. The real work is done in the
mktl Python library; this executable parses command-line flags, invokes
mktl routines to handle any/all requests, and otherwise waits until all
requests are complete. Note that the default is to execute all requests
in parallel.
"""

epilog = """
Example usage:

    mk get rosebud.model rosebud.length
    mk get -s rosebud model length height color
    mk set rosebud.speed=50
    mk set -s rosebud speed=50 passengers=2 --no-wait
    mk watch rosebud.model rosebud.length
    mk watch -s rosebud model length height color
    mk list -s rosebud
    mk list rosebud redflyer
"""

import argparse
import datetime
import mktl
import os
import sys
import threading


def main():

    requests = parse_command_line()
    requests = parse_requests(requests)

    if len(requests.requests) == 0:
        print('No requests specified.')
        sys.exit(1)

    if requests.describe:
        execute_describe_requests(requests)

    if requests.discover:
        execute_discover_requests(requests)

    if requests.get:
        execute_get_requests(requests)

    if requests.set:
        execute_set_requests(requests)

    if requests.list:
        execute_list_requests(requests)

    if requests.watch:
        execute_watch_requests(requests)


main.shutdown = threading.Event()



def parse_command_line():

    arguments = dict()
    arguments['formatter_class'] = argparse.RawDescriptionHelpFormatter
    arguments['description'] = description
    arguments['epilog'] = epilog

    parser = argparse.ArgumentParser(**arguments)

    parser.add_argument('-s', '--store',
        default=None,
        help='Name of an mKTL store to prefix to all subsequent keys.')

    # The argparse.BooleanOptionalAction would be nice to use here instead of
    # 'store_true', because it handles both the --foo and --no-foo case, but
    # that wasn't added until Python 3.9.

    parser.add_argument('--serial',
        default=False,
        action='store_true',
        help='Process all requests serially. The default is to process requests in parallel.')

    parser.add_argument('--no-wait',
        default=False,
        action='store_true',
        help='Do not wait until all set requests are complete before exiting. The default is to wait. --no-wait is not compatible with --serial.')

    parser.add_argument('--formatted',
        default=None,
        action='store_true',
        help='Show the formatted value for get requests, and interpret the provided value as formatted for set requests. This is the default behavior.')

    parser.add_argument('--unformatted',
        default=None,
        action='store_true',
        help='Show the unformatted value for get requests, and interpret the provided value as unformatted for set requests. The default is to use the formatted value.')

    parser.add_argument('type',
        choices=('get', 'set', 'watch', 'describe', 'discover', 'list'),
        type=str.lower,
        help='Request type')

    parser.add_argument('requests',
        nargs='*',
        help='Whitespace-separated sequence of requests. For a get, watch, or describe request, this is a sequence of keys; for a set request, this is a sequence of key=value statements; for a list request this is a sequence of stores; for a discover request this is a sequence of broker addresses.')


    parsed = parser.parse_args()
    parsed.wait = not parsed.no_wait

    if parsed.serial == True and parsed.no_wait == True:
        raise ValueError('--serial is incompatible with --no-wait')

    if len(parsed.requests) == 0 and parsed.type != 'list':
        raise ValueError('no requests specified')

    if parsed.formatted is None and parsed.unformatted is None:
        # Nothing specified, formatted is the default.
        parsed.formatted = True
    elif parsed.formatted is None:
        # Unformatted was specified.
        parsed.formatted = False
    elif parsed.unformatted is None:
        # Formatted was specified.
        parsed.unformatted = False

    if parsed.type == 'set':
        if parsed.formatted == True and parsed.unformatted == True:
            raise ValueError('cannot specify both formatted and unformatted for set requests')
        elif parsed.formatted == False and parsed.unformatted == False:
            raise ValueError('must select one of formatted or unformatted for set requests')

    print_item.formatted = parsed.formatted
    print_item.unformatted = parsed.unformatted

    return parsed



def parse_requests(requests):
    """ Expand keys to include the store name if the store is optionally
        specified. Parse out any 'set' requests into named key/value pairs.
    """

    store = requests.store
    if store is None:
        pass
    else:
        expanded_requests = list()

        for request in requests.requests:
            expanded_requests.append(store + '.' + request)

        requests.requests = expanded_requests


    requests.describe = tuple()
    requests.discover = tuple()
    requests.get = tuple()
    requests.list = list()
    requests.set = dict()
    requests.watch = tuple()

    if requests.type == 'get':
        requests.get = requests.requests

    elif requests.type == 'set':
        for request in requests.requests:
            try:
                key, value = request.split('=', maxsplit=1)
            except:
                raise ValueError('bad key=value assignment: ' + request)

            requests.set[key] = value

    elif requests.type == 'watch':
        requests.watch = requests.requests

    elif requests.type == 'describe':
        requests.describe = requests.requests

    elif requests.type == 'discover':
        requests.discover = requests.requests

    elif requests.type == 'list':
        if requests.store is not None:
            requests.list.append(requests.store)

        requests.list.extend(requests.requests)


    return requests



def execute_describe_requests(requests):

    # This import is only needed here, and might not be used by mKTL,
    # so the import is only done inside this method to limit the runtime
    # impact on the average case (a 'get' or 'set' request).

    import json

    description = dict()

    for key in requests.describe:
        ### This needs to include glob expansion, with additional support
        ### for using % like * for backwards-compatiblity with gshow. The
        ### fnmatch library is probably an easy way to get there.

        ### Test with a 'if '*' in key or '?' in key or '%' in key...'
        ### condition guarding the fnmatch, or just do the replace/fnmatch,
        ### whichever is faster.

        ### This should also treat a bare store name as equivalent to
        ### asking for '*'.

        try:
            item = mktl.get(key)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            sys.exit(1)

        if isinstance(item, mktl.Store):
            store = item
            keys = store.keys()
            keys = list(keys)
            keys.sort()

            for key in keys:
                description[key] = store.config[key]
        else:
            description[key] = item.config

    # The presentation here could be improved, but for early debugging this
    # will get the job done.

    print(json.dumps(description, indent=4))



def execute_discover_requests(requests):
    mktl.discover(*requests.discover)
    hashes = mktl.config.get_hashes()

    stores = hashes.keys()
    stores = list(stores)
    stores.sort()

    print("%d stores available: %s" % (len(stores), ' '.join(stores)))



def execute_get_requests(requests):

    for key in requests.get:
        ### This needs to include glob expansion, with additional support
        ### for using % like * for backwards-compatiblity with gshow. The
        ### fnmatch library is probably an easy way to get there.

        ### Test with a 'if '*' in key or '?' in key or '%' in key...'
        ### condition guarding the fnmatch, or just do the replace/fnmatch,
        ### whichever is faster.

        ### This should also treat a bare store name as equivalent to
        ### asking for '*'.

        try:
            item = mktl.get(key)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            sys.exit(1)

        if isinstance(item, mktl.Store):
            store = item
            for item in store:
                print_item(item, item.value, item._value_timestamp)
        else:
            print_item(item, item.value, item._value_timestamp)



def execute_list_requests(requests):

    for name in requests.list:
        store = mktl.get(name)

        # This inspection deliberately avoids using the Item class in order
        # to minimize potential communication (pub/sub requests, mostly) with
        # a remote daemon.

        keys = store.keys()
        keys = list(keys)
        keys.sort()

        max_key_length = 0
        for key in keys:
            max_key_length = max(max_key_length, len(key))

        max_key_length += len(name) + 1     # Include the 'name.' prefix
        key_justify = max_key_length + 2

        for key in keys:
            line = list()
            full_name = name + '.' + key
            line.append(full_name.ljust(key_justify))

            try:
                type = store.config[key]['type']
            except KeyError:
                pass
            else:
                # Longest typical type is 'enumerated'. Justify accordingly.
                line.append(type.ljust(11))

            try:
                gettable = store.config[key]['gettable']
            except KeyError:
                gettable = True

            try:
                settable = store.config[key]['settable']
            except KeyError:
                settable = True

            if gettable and settable:
                perms = 'rw'
            elif gettable:
                perms = 'r'
            elif settable:
                perms = ' w'
            else:
                perms = None

            if perms:
                line.append(perms)

            line = ' '.join(line)
            print(line)



def execute_set_requests(requests):

    pending = list()
    failed = False

    for key,value in requests.set.items():

        if failed == True and requests.serial == True:
            sys.exit(1)

        try:
            item = mktl.get(key)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            failed = True
            continue

        if requests.formatted:
            value = item.unformat(value)

        try:
            request = item.set(value, wait=requests.serial)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            failed = True
            continue

        pending.append(request)

        if requests.serial == True:
            print("Set %s to %s " % (key, value))


    if requests.serial == False and requests.wait == True:
        for request in pending:
            request.wait()
            key = request.target
            value = request.payload.value
            response = request.response
            error = response.payload.error

            if error is not None and error != '':
                sys.stderr.write("%s failed: %s: %s\n" % (key, error['type'], error['text']))
                failed = True
            else:
                print("Set %s to %s " % (key, value))

    if failed == True:
        sys.exit(1)



def execute_watch_requests(requests):

    for key in requests.watch:
        item = mktl.get(key)
        item.register(print_item, prime=True)

    while True:
        try:
            main.shutdown.wait(30)
        except (KeyboardInterrupt, SystemExit):
            break



def print_item(item, value, timestamp):

        if timestamp is None:
            timestamp = 0.0

        timestamp = datetime.datetime.fromtimestamp(timestamp)
        time_string = timestamp.strftime('%H:%M:%S.%f')

        dot = time_string.index('.')
        if dot > 0:
            milliseconds = dot + 4
            time_string = time_string[:milliseconds]

        try:
            units = item.config['units']
        except KeyError:
            unformatted_units = None
            formatted_units = None
        else:
            if units == '':
                unformatted_units = None
                formatted_units = None
            else:
                try:
                    formatted_units = units['formatted']
                except KeyError:
                    unformatted_units = units['']
                    formatted_units = unformatted_units
                except TypeError:
                    unformatted_units = units
                    formatted_units = units
                else:
                    unformatted_units = units['']

        line = "%s %s: " % (time_string, item.key)

        if print_item.unformatted and print_item.formatted:
            if unformatted_units:
                line = line + "%s %s => " % (value, unformatted_units)
            else:
                line = line + "%s => " % (value)

            value = item.format(value)

            if formatted_units:
                line = line + "%s %s" % (value, formatted_units)
            else:
                line = line + str(value)

        elif print_item.formatted:
            value = item.format(value)
            if formatted_units:
                line = line + "%s %s" % (value, formatted_units)
            else:
                line = line + str(value)

        elif print_item.unformatted:
            if unformatted_units:
                line = line + "%s %s" % (value, unformatted_units)
            else:
                line = line + str(value)

        else:
            raise RuntimeError("don't know how to print!")

        print(line)


print_item.formatted = None
print_item.unformatted = None


if __name__ == '__main__':
    main()


# vim: set expandtab tabstop=8 softtabstop=4 shiftwidth=4 autoindent:
