#! /usr/bin/env python3

description = """
This is the mKTL command line interface. The real work is done in the
mktl Python library; this executable parses command-line flags, invokes
mktl routines to handle any/all requests, and otherwise waits until all
requests are complete. Note that the default is to execute all requests
in parallel.
"""

epilog = """
Example usage:

    mark get rosebud.model rosebud.length
    mark get -s rosebud model length height color
    mark set rosebud.speed=50
    mark set -s rosebud speed=50 passengers=2 --no-wait
    mark watch rosebud.model rosebud.length
    mark watch -s rosebud model length height color
    mark list -s rosebud
    mark list rosebud redflyer
"""

import argparse
import mktl
import sys
import threading


def main():

    requests = parse_command_line()
    requests = parse_requests(requests)

    if requests.describe:
        execute_describe_requests(requests)

    if requests.get:
        execute_get_requests(requests)

    if requests.set:
        execute_set_requests(requests)

    if requests.list:
        execute_list_requests(requests)

    if requests.watch:
        execute_watch_requests(requests)


main.shutdown = threading.Event()



def parse_command_line():

    arguments = dict()
    arguments['formatter_class'] = argparse.RawDescriptionHelpFormatter
    arguments['description'] = description
    arguments['epilog'] = epilog

    parser = argparse.ArgumentParser(**arguments)

    parser.add_argument('-s', '--store',
        default=None,
        help='Name of an mKTL store to prefix to all subsequent keys.')

    # The argparse.BooleanOptionalAction would be nice to use here instead of
    # 'store_true', because it handles both the --foo and --no-foo case, but
    # that wasn't added until Python 3.9.

    parser.add_argument('--serial',
        default=False,
        action='store_true',
        help='Process all requests serially. The default is to process requests in parallel.')
    parser.add_argument('--no-wait',
        default=False,
        action='store_true',
        help='Do not wait until all set requests are complete before exiting. The default is to wait. --no-wait is not compatible with --serial.')

    parser.add_argument('type',
        choices=('get', 'set', 'watch', 'describe', 'list'),
        type=str.lower,
        help='Request type')
    parser.add_argument('requests',
        nargs='*',
        help='Whitespace-separated sequence of requests. For a get or a watch request, this is a sequence of keys; for a set request, this is a sequence of key=value statements. For a list request this is a sequence of stores.')


    parsed = parser.parse_args()
    parsed.wait = not parsed.no_wait

    if parsed.serial == True and parsed.no_wait == True:
        raise ValueError('--serial is incompatible with --no-wait')

    if len(parsed.requests) == 0 and parsed.type != 'list':
        raise ValueError('no requests specified')

    return parsed



def parse_requests(requests):
    """ Expand keys to include the store name if the store is optionally
        specified. Parse out any 'set' requests into named key/value pairs.
    """

    store = requests.store
    if store is None:
        pass
    else:
        expanded_requests = list()

        for request in requests.requests:
            expanded_requests.append(store + '.' + request)

        requests.requests = expanded_requests


    requests.describe = tuple()
    requests.get = tuple()
    requests.list = list()
    requests.set = dict()
    requests.watch = tuple()

    if requests.type == 'get':
        requests.get = requests.requests

    elif requests.type == 'set':
        for request in requests.requests:
            try:
                key, value = request.split('=', maxsplit=1)
            except:
                raise ValueError('bad key=value assignment: ' + request)

            requests.set[key] = value

    elif requests.type == 'watch':
        requests.watch = requests.requests

    elif requests.type == 'describe':
        requests.describe = requests.requests

    elif requests.type == 'list':
        if requests.store is not None:
            requests.list.append(requests.store)

        requests.list.extend(requests.requests)


    return requests



def execute_describe_requests(requests):

    # This import is only needed here, and might not be used by mKTL,
    # so the import is only done inside this method to limit the runtime
    # impact on the average case (a 'get' or 'set' request).

    import json

    description = dict()

    for key in requests.describe:
        ### This needs to include glob expansion, with additional support
        ### for using % like * for backwards-compatiblity with gshow. The
        ### fnmatch library is probably an easy way to get there.

        ### Test with a 'if '*' in key or '?' in key or '%' in key...'
        ### condition guarding the fnmatch, or just do the replace/fnmatch,
        ### whichever is faster.

        ### This should also treat a bare store name as equivalent to
        ### asking for '*'.

        try:
            item = mktl.get(key)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            sys.exit(1)

        description[key] = item.config

    # The presentation here could be improved, but for early debugging this
    # will get the job done.

    print(json.dumps(description, indent=4))



def execute_get_requests(requests):

    for key in requests.get:
        ### This needs to include glob expansion, with additional support
        ### for using % like * for backwards-compatiblity with gshow. The
        ### fnmatch library is probably an easy way to get there.

        ### Test with a 'if '*' in key or '?' in key or '%' in key...'
        ### condition guarding the fnmatch, or just do the replace/fnmatch,
        ### whichever is faster.

        ### This should also treat a bare store name as equivalent to
        ### asking for '*'.

        try:
            item = mktl.get(key)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            sys.exit(1)

        print_item(item, item.value, item._value_timestamp)



def execute_list_requests(requests):

    for name in requests.list:
        store = mktl.get(name)

        # It would be helpful to include additional metadata here besides
        # just the key names.

        keys = store.keys()
        for key in store.keys():
            print(name + '.' + key)



def execute_set_requests(requests):

    responses = list()
    failed = False

    for key,value in requests.set.items():

        if failed == True and requests.serial == True:
            sys.exit(1)

        try:
            item = mktl.get(key)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            failed = True
            continue

        try:
            response = item.set(value, wait=requests.serial)
        except Exception as e:
            sys.stderr.write("%s failed: %s\n" % (key, str(e)))
            failed = True
            continue

        responses.append(response)

        if requests.serial == True:
            print("Set %s to %s " % (key, value))


    if requests.serial == False and requests.wait == True:
        for response in responses:
            response.wait()
            key = response.target
            value = response.payload.value
            print("Set %s to %s " % (key, value))

    if failed == True:
        sys.exit(1)



def execute_watch_requests(requests):

    ### It should be possible to initiate a 'watch' request without
    ### dying if the remote daemon is offline.

    for key in requests.watch:
        item = mktl.get(key)
        item.register(print_item)

    while True:
        try:
            main.shutdown.wait(30)
        except (KeyboardInterrupt, SystemExit):
            break



def print_item(item, value, timestamp):

        ### Needs datetime formatting of timestamp.

        ### There needs to be an option to choose the unformatted value
        ### instead of assuming just the formatted representation. This
        ### is the right place to select one or the other, since value
        ### printing always comes through this method.

        ### Using the Item instance to reformat the value passed as an
        ### argument, instead of using the Item.formatted property,
        ### allows us some flexibility in how to handle formatting.

        value = item.format(value)

        if timestamp is None:
            timestamp = 0.0

        try:
            units = item.config['units']
        except KeyError:
            units = None
        else:
            if units == '':
                units = None

        if units:
            print ("%.3f %s: %s %s" % (timestamp, item.key, value, units))
        else:
            print ("%.3f %s: %s" % (timestamp, item.key, value))



if __name__ == '__main__':
    main()


# vim: set expandtab tabstop=8 softtabstop=4 shiftwidth=4 autoindent:
