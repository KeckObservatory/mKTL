#! /usr/bin/env python3

description = """
This is the mKTL command line interface. The real work is done in the
mktl Python library; this executable parses command-line flags, invokes
mktl routines to handle any/all requests, and otherwise waits until all
requests are complete. Note that the default is to execute all requests
in parallel.
"""

epilog = """
Example usage:

    mark get rosebud.model rosebud.length
    mark get -s rosebud model length height color
    mark set rosebud.speed=50
    mark set -s rosebud speed=50 passengers=2 --no-wait
    mark watch rosebud.model rosebud.length
    mark watch -s rosebud model length height color
    mark list -s rosebud
    mark list rosebud redflyer
"""

import argparse
import threading

import mktl


def main():

    requests = parse_command_line()
    requests = parse_requests(requests)

    if requests.get:
        execute_get_requests(requests)

    if requests.set:
        execute_set_requests(requests)

    if requests.list:
        execute_list_requests(requests)

    if requests.watch:
        execute_watch_requests(requests)


main.shutdown = threading.Event()



def parse_command_line():

    arguments = dict()
    arguments['formatter_class'] = argparse.RawDescriptionHelpFormatter
    arguments['description'] = description
    arguments['epilog'] = epilog

    parser = argparse.ArgumentParser(**arguments)

    parser.add_argument('-s', '--store',
        default=None,
        help='Name of an mKTL store to prefix to all subsequent keys.')
    parser.add_argument('--serial',
        default=False,
        action=argparse.BooleanOptionalAction,
        help='Process all requests serially. The default is to process requests in parallel.')
    parser.add_argument('--wait',
        default=True,
        action=argparse.BooleanOptionalAction,
        help='Wait until all set requests are complete before exiting. The default is to wait. --no-wait is not compatible with --serial.')

    parser.add_argument('type',
        choices=('get', 'set', 'watch', 'list'),
        type=str.lower,
        help='Request type')
    parser.add_argument('requests',
        nargs='*',
        help='Whitespace-separated sequence of requests. For a get or a watch request, this is a sequence of keys; for a set request, this is a sequence of key=value statements. For a list request this is a sequence of stores.')


    parsed = parser.parse_args()

    if parsed.serial == True and parsed.wait == False:
        raise ValueError('--serial requires --wait')

    if len(parsed.requests) == 0 and parsed.type != 'list':
        raise ValueError('no requests specified')

    return parsed



def parse_requests(requests):
    """ Expand keys to include the store name if the store is optionally
        specified. Parse out any 'set' requests into named key/value pairs.
    """

    store = requests.store
    if store is None:
        pass
    else:
        expanded_requests = list()

        for request in requests.requests:
            expanded_requests.append(store + '.' + request)

        requests.requests = expanded_requests


    requests.get = tuple()
    requests.list = list()
    requests.set = dict()
    requests.watch = tuple()

    if requests.type == 'get':
        requests.get = requests.requests

    elif requests.type == 'set':
        for request in requests.requests:
            try:
                key, value = request.split('=', maxsplit=1)
            except:
                raise ValueError('bad key=value assignment: ' + request)

            requests.set[key] = value

    elif requests.type == 'watch':
        requests.watch = requests.requests

    elif requests.type == 'list':
        if requests.store is not None:
            requests.list.append(requests.store)

        requests.list.extend(requests.requests)


    return requests



def execute_get_requests(requests):

    for key in requests.get:
        item = mktl.get(key)
        print_item(item, item.value, item._value_timestamp)



def execute_list_requests(requests):

    for name in requests.list:
        store = mktl.get(name)

        # It would be helpful to include additional metadata here besides
        # just the key names.

        keys = store.keys()
        for key in store.keys():
            print(name + '.' + key)



def execute_set_requests(requests):

    responses = list()

    for key,value in requests.set.items():

        item = mktl.get(key)
        response = item.set(value, wait=requests.serial)
        responses.append(response)

        if requests.serial == True:
            print("Set %s to %s " % (key, value))


    if requests.serial == False and requests.wait == True:
        for response in responses:
            response.wait()
            key = response.target
            value = response.payload.value
            print("Set %s to %s " % (key, value))



def execute_watch_requests(requests):

    for key in requests.watch:
        item = mktl.get(key)
        item.register(print_item)

    while True:
        try:
            main.shutdown.wait(30)
        except (KeyboardInterrupt, SystemExit):
            break



def print_item(item, value, timestamp):

        ### Needs datetime formatting of timestamp.

        if timestamp is None:
            timestamp = 0.0

        print ("%.3f %s: %s" % (timestamp, item.key, value))


if __name__ == '__main__':
    main()


# vim: set expandtab tabstop=8 softtabstop=4 shiftwidth=4 autoindent:
