

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Protocol &mdash; mKTL 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=4bba6b87" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=fd6eb6e6"></script>
      <script src="_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Protocol interface" href="protocol_interface.html" />
    <link rel="prev" title="Configuration syntax" href="configuration.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            mKTL
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="client.html">Client interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="daemon.html">Daemon interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="executables.html">Executables</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuration syntax</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Protocol</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#principles-of-operation">Principles of operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#request-response">Request/response</a></li>
<li class="toctree-l2"><a class="reference internal" href="#message-types">Message types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#message-payload">Message payload</a></li>
<li class="toctree-l2"><a class="reference internal" href="#publish-subscribe">Publish/subscribe</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discovery">Discovery</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="protocol_interface.html">Protocol interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">mKTL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Protocol</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/protocol.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="protocol">
<span id="id1"></span><h1>Protocol<a class="headerlink" href="#protocol" title="Link to this heading"></a></h1>
<p>The mKTL protocol is the primary interface layer for mKTL as a whole;
associated Python code can be considered a reference implementation,
but the intent is for the protocol to be language agnostic. mKTL clients
and daemons communicate using ZeroMQ sockets. This document describes the
socket types used, the formatting of the messages, and the types of requests
that can be made.</p>
<section id="principles-of-operation">
<h2>Principles of operation<a class="headerlink" href="#principles-of-operation" title="Link to this heading"></a></h2>
<p>Unique addressing of daemons within a store is accomplished by the use of
a unique port number to connect to that daemon; messages arriving on a
specific port are thus guaranteed, by construction, to only need decoding
exactly once; there is no envelope for the message contents, such that the
message contents may need to be rerouted to a new location. Each daemon
will use a unique <a class="reference internal" href="#publish"><span class="std std-ref">publish</span></a> and <a class="reference internal" href="#request"><span class="std std-ref">request</span></a>
listener, operating on a unique port on that host.</p>
<p>A given host providing connectivity for mKTL could have thousands of daemons
running locally, each listening on a unique port number. Each daemon deploys
a UDP listener on a predetermined port number (10111) to enable discovery of
daemons on that host; a <a class="reference internal" href="executables.html#mkbrokerd"><span class="std std-ref">dedicated “broker” process</span></a> also
listens on a predetermined port number (10103) to streamline discovery from
the client side. This usage pattern expects there to be a single
<a class="reference internal" href="executables.html#mkbrokerd"><span class="std std-ref">mkbrokerd</span></a> process running on every host running one or more mKTL
daemons. The discovery exchange is <a class="reference internal" href="#discovery"><span class="std std-ref">described below</span></a>
in more detail.</p>
<p>An mKTL proxy, were such a thing to exist, would follow the same principle:
a unique port for each listener of each proxied daemon, which allows the use
of the <code class="docutils literal notranslate"><span class="pre">zmq.proxy()</span></code> method to cleanly bridge between endpoints at the
protocol level without any inspection of message contents, thus ensuring the
proxy has minimal processing overhead.</p>
</section>
<section id="request-response">
<span id="request"></span><h2>Request/response<a class="headerlink" href="#request-response" title="Link to this heading"></a></h2>
<p>The first socket type implements a request/response pattern. This represents
the majority of the interactive traffic between a mKTL client and daemon.
Because requests can be asynchronous, mKTL does not use the REQ/REP
implementation in ZeroMQ, which enforces a strict one request, one response
pattern; instead, we use DEALER/ROUTER, which allows any amount of messages
in any order, in any direction.</p>
<p>The request/response interaction between the client and daemon is a multipart
message, where each part is required and has specific meaning. The reference
implementation provides a <code class="xref py py-class docutils literal notranslate"><span class="pre">mktl.protocol.Message</span></code> class to minimize
the amount of code that has to be aware about the on-the-wire message structure.
For both ends of the request/response exchange, the message parts are:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><em>Field</em></p></td>
<td><p><em>Data type</em></p></td>
</tr>
<tr class="row-even"><td><p><strong>version</strong></p></td>
<td><p>A single ASCII character indicating the mKTL protocol version number.
The initial release of the mKTL protocol uses the version character ‘a’.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>identifier</strong></p></td>
<td><p>A unique identifier for the request. The format of this identifier is
not strict, it could be any byte string (such as a UUID), but the initial
implementation uses a monotonically increasing eight-byte integer. The
identifier is set by the client, and allows the client to tie a response
to the original request. Note that this identifier does not necessarily
have significance on the daemon side, daemons will use their own internal
scheme to uniquely identify requests, but the response will always include
this original identifier.</p></td>
</tr>
<tr class="row-even"><td><p><strong>type</strong></p></td>
<td><p>The message type. This is a short string of characters that identifies
what type of request, or reponse, this message represents. It is one
of the values described in the ref:<cite>message_types</cite> section below.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>target</strong></p></td>
<td><p>The target for this request/response, if any. Not all requests have a
target; responses don’t need to specify it, since it is the identification
number that ties a response to its request. If a target is specified it
is a store or a key, depending on the request; this field will be an empty
byte sequence if the target is not specified.</p></td>
</tr>
<tr class="row-even"><td><p><strong>payload</strong></p></td>
<td><p>The message payload. This is the JSON representation of any additional
data required as part of this exchange; if setting a new value, it would
contain the value; if it is a response containing additional information
it would go here. This field will be an empty byte sequence if no
additional information is required. See the <a class="reference internal" href="#message-payload"><span class="std std-ref">Message payload</span></a> section
for a more complete description of the payload contents.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>bulk</strong></p></td>
<td><p>A bulk byte sequence, typically a component of the payload. This is to
allow the transmission of information like image data, where the bulk
bytes represent the image buffer, and the JSON payload describes how
to interpret the buffer. This field will be an empty byte sequence if
there is no bulk component.</p></td>
</tr>
</tbody>
</table>
<p>Upon receipt of a request the daemon will immediately issue an ACK response.
The absence of a quick response indicates that the daemon is not available,
and the client should immediately raise an error. After the client receives
the initial ACK it should then look for the full response. There will be no
further messages associated with that id number after the full response is
received. A daemon may choose to forego the ACK response, but should only
do so in circumstances where processing a request requires zero additional
processing time.</p>
<p>All requests are handled
fully asynchronously; a client could send a thousand requests in quick
succession, but the responses will not be serialized, and the response order
is not guaranteed. Synchronous behavior, if desired, is implemented by client
code and not in the protocol itself.</p>
<p>Here is an example of what the full exchange on the client side might look
like, in this case handling the exchange as a synchronous request:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">zmq_context</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">zmq</span><span class="o">.</span><span class="n">DEALER</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">zmq</span><span class="o">.</span><span class="n">LINGER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">identity</span> <span class="o">=</span> <span class="n">identity</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">daemon</span><span class="p">)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">send_multipart</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="c1"># milliseconds</span>
<span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">zmq</span><span class="o">.</span><span class="n">ZMQError</span><span class="p">(</span><span class="s1">&#39;no response received in 100 ms&#39;</span><span class="p">)</span>

<span class="n">ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">recv_multipart</span><span class="p">()</span>
<span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">recv_multipart</span><span class="p">()</span>
</pre></div>
</div>
<p>Here is a representation of what the on-the-wire messages might look like
for the simple exchange outlined above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="sa">b</span><span class="s1">&#39;00000023&#39;</span>
<span class="sa">b</span><span class="s1">&#39;GET&#39;</span>
<span class="sa">b</span><span class="s1">&#39;kpfguide.LASTFILENAME&#39;</span>
<span class="sa">b</span><span class="s1">&#39;&#39;</span>
<span class="sa">b</span><span class="s1">&#39;&#39;</span>

<span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="sa">b</span><span class="s1">&#39;00000023&#39;</span>
<span class="sa">b</span><span class="s1">&#39;ACK&#39;</span>
<span class="sa">b</span><span class="s1">&#39;&#39;</span>
<span class="sa">b</span><span class="s1">&#39;&#39;</span>
<span class="sa">b</span><span class="s1">&#39;&#39;</span>

<span class="sa">b</span><span class="s1">&#39;a&#39;</span>
<span class="sa">b</span><span class="s1">&#39;00000023&#39;</span>
<span class="sa">b</span><span class="s1">&#39;REP&#39;</span>
<span class="sa">b</span><span class="s1">&#39;&#39;</span>
<span class="sa">b</span><span class="s1">&#39;{&quot;value&quot;: /sdata1701/kpf1/2025-06-23/image_672.fits&#39;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mf">234.23</span><span class="p">}</span><span class="s1">&#39;</span>
<span class="sa">b</span><span class="s1">&#39;&#39;</span>
</pre></div>
</div>
</section>
<section id="message-types">
<span id="id2"></span><h2>Message types<a class="headerlink" href="#message-types" title="Link to this heading"></a></h2>
<p>This section describes the various requests a client can make of the mKTL
daemon via the request/response socket. An additional message type, the PUB,
also exists, but has its own message structure outside this scheme.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><em>Message type</em></p></td>
<td><p><em>Description</em></p></td>
</tr>
<tr class="row-even"><td><p><strong>GET</strong></p></td>
<td><p>Request the current value for a single item.
The target is always the name of the store, and the key for the item,
concatenated with a period. No additional payload is required for a
basic GET request.</p>
<p>The default behavior for a GET request is for a cached value to be
returned by the handling daemon. A client can explicitly request an
up-to-date value by setting the ‘refresh’ field in the payload to
‘True’; see the <a class="reference internal" href="#message-payload"><span class="std std-ref">Message payload</span></a> section for additional details.</p>
<p>The payload of the response will contain ‘value’ and ‘time’ fields,
corresponding to the item value and the last-changed timestamp. If
the item has a bulk data component, the payload will instead describe
the bulk data.</p>
</td>
</tr>
<tr class="row-odd"><td><p><strong>SET</strong></p></td>
<td><p>Request a change to the value of a single key. Depending on the daemon,
this could result in a variety of behavior, from simply caching the value
to slewing a telescope, and anything in-between. The final response
indicates the request is complete but does not indicate what the new
item value is.</p>
<p>The <a class="reference internal" href="#message-payload"><span class="std std-ref">Message payload</span></a> for a SET request is the same as the payload
for a GET response, except that the ‘time’ field is not required or
expected, and there are additional fields set by the client to describe
the origin of the request.</p>
</td>
</tr>
<tr class="row-even"><td><p><strong>HASH</strong></p></td>
<td><p>Request the current hash identifiers for any known configuration blocks
of a single mKTL store. All available hash identifiers, for all known
stores, will be returned if no store name is specified in the target
field. An error will be
returned if a store is requested and the responding daemon does not have
a cached configuration for that store.</p>
<p>The hash is 32 hexadecimal integers. The actual hash format is not
significant, as long as the source of authority is consistent about
which hash format it uses, and the format can be transmitted as 32
hexadecimal integers.</p>
<p>To unify processing the response value is always a dictionary of
dictionaries, even if only one hash is available.</p>
<p>Example response values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;kpfguide&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;uuid1&#39;</span><span class="p">:</span> <span class="mh">0x84a30b35</span><span class="o">...</span><span class="p">,</span>
              <span class="s1">&#39;uuid2&#39;</span><span class="p">:</span> <span class="mh">0x983ae10f</span><span class="o">...</span><span class="p">}}</span>

<span class="p">{</span><span class="s1">&#39;kpfguide&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;uuid1&#39;</span><span class="p">:</span> <span class="mh">0x84a30b35</span><span class="o">...</span><span class="p">,</span>
              <span class="s1">&#39;uuid2&#39;</span><span class="p">:</span> <span class="mh">0x983ae10f</span><span class="o">...</span><span class="p">},</span>
 <span class="s1">&#39;kpfmet&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;uuid6&#39;</span><span class="p">:</span> <span class="mh">0xe0377e7d</span><span class="o">...</span><span class="p">,</span>
            <span class="s1">&#39;uuid7&#39;</span><span class="p">:</span> <span class="mh">0x7735a20a</span><span class="o">...</span><span class="p">,</span>
            <span class="s1">&#39;uuid8&#39;</span><span class="p">:</span> <span class="mh">0x88645dab</span><span class="o">...</span><span class="p">,</span>
            <span class="s1">&#39;uuid9&#39;</span><span class="p">:</span> <span class="mh">0x531c14fd</span><span class="o">...</span><span class="p">}}</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p><strong>CONFIG</strong></p></td>
<td><p>Request the full configuration contents for a single mKTL store.
There is no option to dump the configuration data for all known stores,
a target must always be specified.
A typical client interaction will request the configuration hash first,
and if the hash for the cached local copy is not a match, request the
full contents from the daemon to update the local cache.</p>
<p>The configuration contents are not fully described here, this is just
a description of the request. See the
<a class="reference internal" href="configuration.html#configuration"><span class="std std-ref">configuration documentation</span></a> for a full description
of the data format.</p>
</td>
</tr>
<tr class="row-even"><td><p><strong>ACK</strong></p></td>
<td><p>Immediate acknowledgement of a request; this message type originates from
a daemon, only in response to a request. If this response is not received
with a very small time window after the initial request, the client can
and should assume the daemon handling that request is offline. The
acknowledgement confers no additional information beyond a positive
affirmation that the request has been received.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>REP</strong></p></td>
<td><p>A response to a direct request; this message type originates from a
daemon, only in response to a request. This response will contain the
full payload to satisfy the request, any error text related to a problem
satisfying the request, or be an empty indication that the request has
been completed.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="message-payload">
<span id="id3"></span><h2>Message payload<a class="headerlink" href="#message-payload" title="Link to this heading"></a></h2>
<p>The payload of a message is a JSON associative array. The fields will vary
depending on the message type, and are optional in nearly all circumstances,
but each field has a consistent meaning. Arbitrary additional fields are
allowed, but a standard mKTL client will not notice or handle them.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><em>Payload field</em></p></td>
<td><p><em>Description</em></p></td>
</tr>
<tr class="row-even"><td><p><strong>value</strong></p></td>
<td><p>The base representation of the value being transmitted in this message.
For a GET response or a SET request, this would be the item value;
depending on the item type this could be a boolean, numeric, or string
value, or any valid data that can be serialized as JSON.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>time</strong></p></td>
<td><p>The timestamp associated with the transmitted value. This should be
interpreted as the “last modified” timestamp for an item, indicating
when the item assumed the transmitted value. The timestamp is a numeric
representation of UNIX epoch seconds.</p></td>
</tr>
<tr class="row-even"><td><p><strong>error</strong></p></td>
<td><p>A JSON dictionary with information about any error that occurred while
processing the request. If the value is not present or is the JSON null
value, no error occurred. If it is present, it will have these fields:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>type</strong></p></td>
<td><p>Analagous to the Python exception type
(ValueError, TypeError, etc.).</p></td>
</tr>
<tr class="row-even"><td><p><strong>text</strong></p></td>
<td><p>Descriptive text of the error.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>debug</strong></p></td>
<td><p>Optional additional information about the
error, such as a Python traceback.</p></td>
</tr>
</tbody>
</table>
<p>The intent of this error field is not to provide enough information for
debugging of code, it is intended to provide enough information for the
client to perform meaningful error handling.</p>
</td>
</tr>
<tr class="row-odd"><td><p><strong>refresh</strong></p></td>
<td><p>An optional field associated with a GET request. If this field is
present, and it is set to True, the daemon processing the request is
expected to ignore cached data and retrieve the most current value
for the target item. For example, if the item represents a temperature
reading, the daemon would be expected to query the hardware controller,
update its local cache, and return the result to the requesting client.</p></td>
</tr>
<tr class="row-even"><td><p><strong>shape</strong></p></td>
<td><p>One of the two required fields in order to describe a bulk data array.
This defines the dimensions of the bulk data array, and is interpreted
the same way as the ‘shape’ parameter for a numpy ndarray.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>dtype</strong></p></td>
<td><p>One of the two required fields in order to describe a bulk data array.
This defines the data type of the bulk data array, and is interpreted
the same way as the ‘dtype’ parameter for a numpy ndarray. If starting
from an ndarray, the dtype is the string representation of the .dtype
attribute of that array; when recreating an ndarray, this string is
used to get the matching dtype attribute from the numpy module. In
Python:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">payload</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">my_numpy_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">numpy</span><span class="p">,</span> <span class="n">payload</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">])</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><p><strong>_user</strong></p></td>
<td><p>The user name associated with a SET request.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>_hostname</strong></p></td>
<td><p>The host name from which a SET request originated.</p></td>
</tr>
<tr class="row-even"><td><p><strong>_pid</strong></p></td>
<td><p>The process identifier associated with a SET request.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>_ppid</strong></p></td>
<td><p>The identifier for the parent process associated with a SET request.</p></td>
</tr>
<tr class="row-even"><td><p><strong>_executable</strong></p></td>
<td><p>The executable running the process associated with a SET request.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>_argv</strong></p></td>
<td><p>All additional command line arguments provided to the process associated
with a SET request.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="publish-subscribe">
<span id="publish"></span><h2>Publish/subscribe<a class="headerlink" href="#publish-subscribe" title="Link to this heading"></a></h2>
<p>The second socket type implements a publish/subscribe socket pattern. The
desired functionality in mKTL is a neat match for the PUB/SUB socket pattern
offered by ZeroMQ:</p>
<blockquote>
<div><ul class="simple">
<li><p>SUB clients subscribe to one or more topics from
a given PUB socket, or can subscribe to all topics
by subscribing to the empty string. This aligns well
with existing usage patterns, where KTL keyword
names and EPICS channel names are treated as unique
identifiers, and map easily to a PUB/SUB topic.</p></li>
<li><p>The filtering of topics occurs on the daemon side,
so if a PUB is publishing a mixture of high-frequency
values or large broadcasts, and a client is not
subscribed to those specific topics, the broadcasts
are never sent to the client.</p></li>
</ul>
</div></blockquote>
<p>The formatting of the PUB message is very similar to what is described
above for the <a class="reference internal" href="#request"><span class="std std-ref">request/response multipart message format</span></a>.
Some fields are not necessary for the PUB variant, and in order for the
topic matching to work the topic must be the first component of a multipart
message. The fields are as follows:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><em>Field</em></p></td>
<td><p><em>Data type</em></p></td>
</tr>
<tr class="row-even"><td><p><strong>topic</strong></p></td>
<td><p>For a typical broadcast the topic will be the full key for a single
mKTL item. This is similar to the ‘target’ field in a
<a class="reference internal" href="#request"><span class="std std-ref">request/response message</span></a>. For all mKTL addressing
the topic appends a trailing ‘.’ in order to prevent unwanted substring
matching between similarly
named keys. Likewise, because of the ZeroMQ behavior around leading
substrings, any expanded use of mKTL PUB/SUB behavior will use a
leading prefix to distinguish it from other message types. For example,
broadcasting all SET requests with a leading ‘set:’ prefix, or
broadcasting a bundle of related mKTL items with a leading ‘bundle:’
prefix.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>version</strong></p></td>
<td><p>A single ASCII character indicating the mKTL protocol version number.
The initial release of the mKTL protocol uses the version character ‘a’.</p></td>
</tr>
<tr class="row-even"><td><p><strong>payload</strong></p></td>
<td><p>The message payload, with exactly the same contents as
<a class="reference internal" href="#message-payload"><span class="std std-ref">described above</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>bulk</strong></p></td>
<td><p>A bulk byte sequence, with exactly the same contents as the
<a class="reference internal" href="#request"><span class="std std-ref">request/response message</span></a>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="discovery">
<span id="id4"></span><h2>Discovery<a class="headerlink" href="#discovery" title="Link to this heading"></a></h2>
<p>The UDP discovery layer takes advantage of a feature of UDP listeners: not only
are you allowed to have multiple listeners on the same port, but they will all
respond to an incoming broadcast message. Some care thus needs to be taken to
make sure these responses do not lend themselves to a denial of service attack.
Regardless, this feature allows every daemon to create a listener on the same
port, which greatly simplfies periodic discovery.</p>
<p>The discovery of daemons is a two-part process; rather than ask every daemon
to cache the configuration for every other daemon on its local network, the
caching of configuration data is handled by <a class="reference internal" href="executables.html#mkbrokerd"><span class="std std-ref">mkbrokerd</span></a>; when a client
issues a discovery broadcast, it is not looking for responses from individual
daemons, it is looking for responses from a <a class="reference internal" href="executables.html#mkbrokerd"><span class="std std-ref">mkbrokerd</span></a> process.</p>
<p>This two-step approach, of contacting the broker process, and subsequently
contacting the authoritative daemon, could be avoided if every local daemon
caching the configuration of every other local daemon; however, a typical
client will cache the response, and discovery is only invoked if the cached
daemon cannot be reached, so the impact of the additional inefficiency is
low. The upside of splitting the discovery into two steps is that reduces
the need for consistent chatter between daemons, which would otherwise grow
exponentially with the number of locally reachable daemons.</p>
<p>There are four shared secrets used in the discovery exchange:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><em>Secret</em></p></th>
<th class="head"><p><em>Description</em></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>broker port</strong></p></td>
<td><p>The UDP port used to discover locally accessible
<a class="reference internal" href="executables.html#mkbrokerd"><span class="std std-ref">mkbrokerd</span></a> processes. Clients use this port to find
all such processes. The port number is 10103.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>daemon port</strong></p></td>
<td><p>The UDP port used to discover locally accessible mKTL daemons.
<a class="reference internal" href="executables.html#mkbrokerd"><span class="std std-ref">mkbrokerd</span></a> uses this port to find all such daemons.
The port number is 10111.</p></td>
</tr>
<tr class="row-even"><td><p><strong>call</strong></p></td>
<td><p>An arbitrary string used by the discoverer to trigger a
response from the listener. The string value is <code class="docutils literal notranslate"><span class="pre">I</span> <span class="pre">heard</span> <span class="pre">it</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>response</strong></p></td>
<td><p>An arbitrary string used by the listener to respond to any
received calls. The string value is <code class="docutils literal notranslate"><span class="pre">on</span> <span class="pre">the</span> <span class="pre">X:</span></code>.</p></td>
</tr>
</tbody>
</table>
<p>The purpose of discovery is to convey a single piece of information: what is
the port number of an actual mKTL request handler on this host? That port
number, encoded as a string representation of an integer, is the sole additional
component of the response after the colon. For example, if a daemon has a
request port listening on port 10079, the full exchange (discovery request,
discovery response) would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sa">b</span><span class="s1">&#39;I heard it&#39;</span>

<span class="sa">b</span><span class="s1">&#39;on the X:10079&#39;</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="configuration.html" class="btn btn-neutral float-left" title="Configuration syntax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="protocol_interface.html" class="btn btn-neutral float-right" title="Protocol interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright W. M. Keck Observatory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>